"""
Bot Telegram para Resolver QuestÃµes COC
VocÃª gerencia mÃºltiplas contas de clientes via Telegram
Usa DeepSeek (barato) ou Claude (preciso) para resolver

Requisitos:
pip install python-telegram-bot selenium openai anthropic pillow python-dotenv
"""

import os
import asyncio
import base64
import json
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from openai import OpenAI
import anthropic
from dotenv import load_dotenv
import time

load_dotenv()

# ConfiguraÃ§Ãµes
TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')  # Mais barato
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')  # Mais preciso
YOUR_TELEGRAM_ID = int(os.getenv('YOUR_TELEGRAM_ID'))  # SÃ³ vocÃª pode usar

# Cliente IA
deepseek_client = OpenAI(
    api_key=DEEPSEEK_API_KEY,
    base_url="https://api.deepseek.com/v1"
)
claude_client = anthropic.Anthropic(api_key=ANTHROPIC_API_KEY)

# Armazena sessÃµes dos clientes
sessions = {}

class ClientSession:
    """SessÃ£o de um cliente"""
    
    def __init__(self, client_name, username, password):
        self.client_name = client_name
        self.username = username
        self.password = password
        self.driver = None
        self.is_logged_in = False
        self.questions_solved = 0
        self.created_at = datetime.now()
        
    def setup_driver(self):
        """Configura Chrome headless"""
        chrome_options = Options()
        chrome_options.add_argument('--headless')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--window-size=1920,1080')
        chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
        
        self.driver = webdriver.Chrome(options=chrome_options)
        
    def login(self):
        """Faz login na conta do cliente"""
        try:
            if not self.driver:
                self.setup_driver()
            
            self.driver.get("https://jornada.coc.com.br/entrar/")
            
            wait = WebDriverWait(self.driver, 15)
            
            # Preenche login
            username_field = wait.until(EC.presence_of_element_located((By.NAME, "username")))
            username_field.clear()
            username_field.send_keys(self.username)
            
            password_field = self.driver.find_element(By.NAME, "password")
            password_field.clear()
            password_field.send_keys(self.password)
            
            # Clica em entrar
            login_button = self.driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
            login_button.click()
            
            time.sleep(4)
            
            # Verifica sucesso
            if "entrar" not in self.driver.current_url.lower():
                self.is_logged_in = True
                return True, f"âœ… Logado como {self.client_name}"
            else:
                return False, "âŒ Login falhou - credenciais invÃ¡lidas"
                
        except Exception as e:
            return False, f"âŒ Erro: {str(e)}"
    
    def get_screenshot(self):
        """Captura tela atual"""
        try:
            screenshot = self.driver.get_screenshot_as_png()
            return base64.b64encode(screenshot).decode('utf-8')
        except:
            return None
    
    def extract_question(self):
        """Extrai texto da questÃ£o e alternativas"""
        try:
            question_text = ""
            alternatives = []
            
            # Tenta pegar a questÃ£o
            question_selectors = [
                ".question-text", ".enunciado", ".pergunta",
                "[class*='question']", "[class*='Quest']",
                "div[class*='enunciado']", "p[class*='question']"
            ]
            
            for selector in question_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    texts = [el.text.strip() for el in elements if el.text.strip()]
                    if texts:
                        question_text = "\n".join(texts)
                        break
                except:
                    continue
            
            # Tenta pegar alternativas
            alt_selectors = [
                ".alternative", ".alternativa", ".option",
                "[class*='alternative']", "[class*='option']",
                "label[for*='alt']", "div[class*='Alternative']"
            ]
            
            for selector in alt_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    alts = [el.text.strip() for el in elements if el.text.strip()]
                    if alts and len(alts) >= 3:  # Pelo menos 3 alternativas
                        alternatives = alts
                        break
                except:
                    continue
            
            return {
                "question": question_text,
                "alternatives": alternatives,
                "url": self.driver.current_url
            }
            
        except Exception as e:
            return {"question": "", "alternatives": [], "url": "", "error": str(e)}
    
    def select_answer(self, answer_letter):
        """Seleciona uma alternativa"""
        try:
            answer_index = ord(answer_letter.upper()) - 65
            
            # Tenta vÃ¡rios tipos de seletores
            selectors = [
                # Por valor
                f"input[value='{answer_letter}']",
                f"input[value='{answer_letter.upper()}']",
                f"input[value='{answer_letter.lower()}']",
                
                # Por ID
                f"input[id*='alt{answer_letter}']",
                f"input[id*='alternativa{answer_letter}']",
                
                # Por label
                f"label[for*='alt{answer_letter}']",
                
                # Por Ã­ndice
                f".alternative:nth-child({answer_index + 1})",
                f".alternativa:nth-child({answer_index + 1})",
                f".option:nth-child({answer_index + 1})"
            ]
            
            for selector in selectors:
                try:
                    element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    self.driver.execute_script("arguments[0].click();", element)
                    time.sleep(1)
                    return True, f"âœ… Alternativa {answer_letter.upper()} selecionada"
                except:
                    continue
            
            return False, "âš ï¸ NÃ£o consegui selecionar automaticamente"
            
        except Exception as e:
            return False, f"âŒ Erro: {str(e)}"
    
    def submit_answer(self):
        """Envia a resposta"""
        try:
            submit_selectors = [
                "button[type='submit']",
                "button[class*='submit']",
                "button[class*='enviar']",
                "button[class*='confirmar']",
                "input[type='submit']",
                "button:contains('Enviar')",
                "button:contains('Confirmar')"
            ]
            
            for selector in submit_selectors:
                try:
                    element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    self.driver.execute_script("arguments[0].click();", element)
                    time.sleep(2)
                    self.questions_solved += 1
                    return True, f"âœ… Resposta enviada! Total resolvidas: {self.questions_solved}"
                except:
                    continue
            
            return False, "âš ï¸ BotÃ£o enviar nÃ£o encontrado"
            
        except Exception as e:
            return False, f"âŒ Erro: {str(e)}"
    
    def next_question(self):
        """Vai para prÃ³xima questÃ£o"""
        try:
            next_selectors = [
                "button[class*='next']",
                "button[class*='proximo']",
                "button[class*='proxima']",
                "a[class*='next']",
                "button:contains('PrÃ³xim')"
            ]
            
            for selector in next_selectors:
                try:
                    element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    element.click()
                    time.sleep(2)
                    return True, "â¡ï¸ PrÃ³xima questÃ£o"
                except:
                    continue
            
            return False, "âš ï¸ BotÃ£o prÃ³xima nÃ£o encontrado"
            
        except Exception as e:
            return False, f"âŒ Erro: {str(e)}"
    
    def close(self):
        """Fecha sessÃ£o"""
        if self.driver:
            self.driver.quit()
        self.is_logged_in = False


def solve_with_deepseek(question_data, screenshot_b64):
    """Resolve com DeepSeek (barato - $0.14 por 1M tokens)"""
    try:
        messages = [
            {
                "role": "system",
                "content": "VocÃª Ã© um especialista em resolver questÃµes educacionais. Analise a questÃ£o e indique APENAS a letra da alternativa correta (A, B, C, D ou E)."
            },
            {
                "role": "user",
                "content": f"""QuestÃ£o:
{question_data.get('question', 'Ver imagem')}

Alternativas:
{chr(10).join([f"{chr(65+i)}. {alt}" for i, alt in enumerate(question_data.get('alternatives', []))])}

Responda APENAS no formato:
RESPOSTA: [letra]
CONFIANÃ‡A: [0-100]%
EXPLICAÃ‡ÃƒO: [1 linha]"""
            }
        ]
        
        # DeepSeek ainda nÃ£o suporta imagens nativamente, entÃ£o usa sÃ³ texto
        response = deepseek_client.chat.completions.create(
            model="deepseek-chat",
            messages=messages,
            temperature=0.3,
            max_tokens=300
        )
        
        return {
            "success": True,
            "response": response.choices[0].message.content,
            "model": "DeepSeek",
            "cost": "~$0.0001"
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}


def solve_with_claude(question_data, screenshot_b64):
    """Resolve com Claude (mais preciso - $3 por 1M tokens)"""
    try:
        prompt = f"""Analise esta questÃ£o educacional com MÃXIMA ATENÃ‡ÃƒO e indique a resposta correta.

QUESTÃƒO:
{question_data.get('question', 'Ver imagem')}

ALTERNATIVAS:
{chr(10).join([f"{chr(65+i)}. {alt}" for i, alt in enumerate(question_data.get('alternatives', []))])}

INSTRUÃ‡Ã•ES:
1. Leia com atenÃ§Ã£o a questÃ£o E a imagem
2. Analise cada alternativa
3. Identifique a ÃšNICA correta
4. Seja preciso - vocÃª tem alta taxa de acerto

Responda APENAS:
RESPOSTA: [letra]
CONFIANÃ‡A: [0-100]%
EXPLICAÃ‡ÃƒO: [breve - mÃ¡ximo 2 linhas]"""

        message = claude_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=500,
            messages=[{
                "role": "user",
                "content": [
                    {
                        "type": "image",
                        "source": {
                            "type": "base64",
                            "media_type": "image/png",
                            "data": screenshot_b64
                        }
                    },
                    {"type": "text", "text": prompt}
                ]
            }]
        )
        
        return {
            "success": True,
            "response": message.content[0].text,
            "model": "Claude Sonnet 4",
            "cost": "~$0.003"
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}


# ==================== HANDLERS TELEGRAM ====================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /start"""
    user_id = update.effective_user.id
    
    # SÃ³ vocÃª pode usar
    if user_id != YOUR_TELEGRAM_ID:
        await update.message.reply_text("âŒ Acesso negado. Este bot Ã© privado.")
        return
    
    text = """
ğŸ¤– **Bot COC - Resolver QuestÃµes**

Comandos disponÃ­veis:

ğŸ“‹ **Gerenciar Clientes:**
/add_cliente - Adicionar novo cliente
/listar - Ver clientes ativos
/trocar - Trocar de cliente

ğŸ¯ **Resolver QuestÃµes:**
/resolver - Resolver questÃ£o atual
/auto - Resolver + selecionar + enviar
/proximo - PrÃ³xima questÃ£o

ğŸ“Š **Utilidades:**
/screenshot - Ver tela atual
/status - Status da sessÃ£o
/sair - Encerrar sessÃ£o

ğŸ’¡ **Dica:** Use /add_cliente para comeÃ§ar!
    """
    
    await update.message.reply_text(text, parse_mode='Markdown')


async def add_cliente(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Adiciona novo cliente"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    await update.message.reply_text(
        "ğŸ“ **Adicionar Cliente**\n\n"
        "Envie no formato:\n"
        "`nome_cliente usuario senha`\n\n"
        "Exemplo:\n"
        "`JoÃ£o joao.silva senha123`",
        parse_mode='Markdown'
    )
    
    context.user_data['awaiting_client'] = True


async def handle_add_client(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processa dados do novo cliente"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID or not context.user_data.get('awaiting_client'):
        return
    
    try:
        parts = update.message.text.strip().split()
        if len(parts) != 3:
            await update.message.reply_text("âŒ Formato invÃ¡lido! Use: `nome usuario senha`", parse_mode='Markdown')
            return
        
        client_name, username, password = parts
        
        msg = await update.message.reply_text(f"â³ Conectando na conta de {client_name}...")
        
        # Cria sessÃ£o
        session = ClientSession(client_name, username, password)
        success, message = session.login()
        
        if success:
            sessions[client_name] = session
            context.user_data['current_client'] = client_name
            
            keyboard = [
                [InlineKeyboardButton("ğŸ¯ Resolver QuestÃ£o", callback_data='resolver')],
                [InlineKeyboardButton("ğŸ¤– Modo Auto", callback_data='auto')],
                [InlineKeyboardButton("ğŸ“¸ Screenshot", callback_data='screenshot')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await msg.edit_text(
                f"âœ… **Cliente adicionado: {client_name}**\n\n"
                f"Total de questÃµes resolvidas: 0\n"
                f"Status: ğŸŸ¢ Conectado\n\n"
                f"Use os botÃµes abaixo ou comandos!",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await msg.edit_text(f"âŒ {message}")
            session.close()
        
        context.user_data['awaiting_client'] = False
        
    except Exception as e:
        await update.message.reply_text(f"âŒ Erro: {str(e)}")
        context.user_data['awaiting_client'] = False


async def listar_clientes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lista clientes ativos"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    if not sessions:
        await update.message.reply_text("ğŸ“‹ Nenhum cliente ativo.\n\nUse /add_cliente para adicionar.")
        return
    
    text = "ğŸ“‹ **Clientes Ativos:**\n\n"
    
    for name, session in sessions.items():
        status = "ğŸŸ¢" if session.is_logged_in else "ğŸ”´"
        text += f"{status} **{name}**\n"
        text += f"   â”” QuestÃµes: {session.questions_solved}\n"
        text += f"   â”” Login: {session.username}\n\n"
    
    current = context.user_data.get('current_client', '')
    if current:
        text += f"â–¶ï¸ Atual: **{current}**"
    
    await update.message.reply_text(text, parse_mode='Markdown')


async def trocar_cliente(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Troca de cliente"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    if not sessions:
        await update.message.reply_text("âŒ Nenhum cliente cadastrado.")
        return
    
    keyboard = []
    for name in sessions.keys():
        keyboard.append([InlineKeyboardButton(f"ğŸ‘¤ {name}", callback_data=f"switch_{name}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "ğŸ‘¥ **Escolha o cliente:**",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )


async def resolver_questao(update: Update, context: ContextTypes.DEFAULT_TYPE, use_claude=False):
    """Resolve a questÃ£o atual"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    current_client = context.user_data.get('current_client')
    
    if not current_client or current_client not in sessions:
        await update.message.reply_text("âŒ Nenhum cliente selecionado. Use /add_cliente")
        return
    
    session = sessions[current_client]
    
    if not session.is_logged_in:
        await update.message.reply_text("âŒ SessÃ£o expirada. Adicione o cliente novamente.")
        return
    
    msg = await update.message.reply_text(f"ğŸ” Analisando questÃ£o de **{current_client}**...", parse_mode='Markdown')
    
    # Captura questÃ£o
    question_data = session.extract_question()
    screenshot = session.get_screenshot()
    
    if not screenshot:
        await msg.edit_text("âŒ Erro ao capturar tela")
        return
    
    # Resolve com IA
    await msg.edit_text(f"ğŸ¤– Resolvendo com {'Claude (preciso)' if use_claude else 'DeepSeek (rÃ¡pido)'}...")
    
    if use_claude:
        solution = solve_with_claude(question_data, screenshot)
    else:
        solution = solve_with_deepseek(question_data, screenshot)
    
    if not solution['success']:
        await msg.edit_text(f"âŒ Erro: {solution.get('error')}")
        return
    
    # Extrai letra da resposta
    response_text = solution['response']
    answer_letter = None
    
    if 'RESPOSTA:' in response_text:
        try:
            line = [l for l in response_text.split('\n') if 'RESPOSTA:' in l][0]
            # Pega primeira letra maiÃºscula apÃ³s "RESPOSTA:"
            for char in line.split('RESPOSTA:')[1]:
                if char.upper() in 'ABCDE':
                    answer_letter = char.upper()
                    break
        except:
            pass
    
    # Monta resposta
    result_text = f"ğŸ¯ **Cliente:** {current_client}\n"
    result_text += f"ğŸ¤– **Modelo:** {solution['model']}\n"
    result_text += f"ğŸ’° **Custo:** {solution['cost']}\n\n"
    result_text += f"ğŸ“ **Resposta:**\n{response_text}\n"
    
    # BotÃµes de aÃ§Ã£o
    keyboard = []
    if answer_letter:
        keyboard.append([InlineKeyboardButton(f"âœ… Selecionar {answer_letter}", callback_data=f"select_{answer_letter}")])
        context.user_data['last_answer'] = answer_letter
    
    keyboard.append([InlineKeyboardButton("ğŸ“¤ Enviar", callback_data='submit')])
    keyboard.append([InlineKeyboardButton("â¡ï¸ PrÃ³xima", callback_data='next')])
    keyboard.append([InlineKeyboardButton("ğŸ”„ Tentar Claude", callback_data='retry_claude')])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await msg.edit_text(result_text, reply_markup=reply_markup, parse_mode='Markdown')


async def auto_resolver(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Modo automÃ¡tico: resolve + seleciona + envia"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    current_client = context.user_data.get('current_client')
    
    if not current_client or current_client not in sessions:
        await update.message.reply_text("âŒ Nenhum cliente selecionado")
        return
    
    session = sessions[current_client]
    
    msg = await update.message.reply_text(f"ğŸ¤– **Modo AUTO** - {current_client}\n\nâ³ Processando...", parse_mode='Markdown')
    
    # 1. Captura
    question_data = session.extract_question()
    screenshot = session.get_screenshot()
    
    # 2. Resolve com Claude (mais preciso)
    await msg.edit_text(f"ğŸ¤– **Modo AUTO**\n\nğŸ” Resolvendo...")
    solution = solve_with_claude(question_data, screenshot)
    
    if not solution['success']:
        await msg.edit_text(f"âŒ Erro: {solution['error']}")
        return
    
    # 3. Extrai resposta
    response_text = solution['response']
    answer_letter = None
    
    if 'RESPOSTA:' in response_text:
        try:
            line = [l for l in response_text.split('\n') if 'RESPOSTA:' in l][0]
            for char in line.split('RESPOSTA:')[1]:
                if char.upper() in 'ABCDE':
                    answer_letter = char.upper()
                    break
        except:
            pass
    
    if not answer_letter:
        await msg.edit_text(f"âŒ NÃ£o consegui identificar a resposta:\n\n{response_text}")
        return
    
    # 4. Seleciona
    await msg.edit_text(f"ğŸ¤– **Modo AUTO**\n\nâœï¸ Selecionando {answer_letter}...")
    success, message = session.select_answer(answer_letter)
    
    if not success:
        await msg.edit_text(f"âš ï¸ {message}\n\nğŸ“ Resposta: {answer_letter}\n{response_text}")
        return
    
    # 5. Envia
    await msg.edit_text(f"ğŸ¤– **Modo AUTO**\n\nğŸ“¤ Enviando...")
    time.sleep(1)
    success, message = session.submit_answer()
    
    # Resultado final
    result = f"âœ… **QUESTÃƒO RESOLVIDA AUTOMATICAMENTE**\n\n"
    result += f"ğŸ‘¤ Cliente: {current_client}\n"
    result += f"âœï¸ Resposta: {answer_letter}\n"
    result += f"ğŸ“Š Total resolvidas: {session.questions_solved}\n\n"
    result += f"ğŸ’¡ {response_text}"
    
    keyboard = [[InlineKeyboardButton("â¡ï¸ PrÃ³xima QuestÃ£o", callback_data='next')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await msg.edit_text(result, reply_markup=reply_markup, parse_mode='Markdown')


async def screenshot_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia screenshot da tela atual"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    current_client = context.user_data.get('current_client')
    
    if not current_client or current_client not in sessions:
        await update.message.reply_text("âŒ Nenhum cliente selecionado")
        return
    
    session = sessions[current_client]
    screenshot_b64 = session.get_screenshot()
    
    if screenshot_b64:
        # Converte base64 para bytes
        screenshot_bytes = base64.b64decode(screenshot_b64)
        await update.message.reply_photo(
            photo=screenshot_bytes,
            caption=f"ğŸ“¸ Tela de {current_client}\nğŸŒ {session.driver.current_url}"
        )
    else:
        await update.message.reply_text("âŒ Erro ao capturar screenshot")


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler dos botÃµes inline"""
    query = update.callback_query
    user_id = query.from_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        await query.answer("âŒ Acesso negado")
        return
    
    await query.answer()
    
    data = query.data
    current_client = context.user_data.get('current_client')
    
    if data == 'resolver':
        # Simula comando /resolver
        await query.message.reply_text("ğŸ” Resolvendo...")
        context.user_data['_temp_update'] = query
        await resolver_questao(query, context, use_claude=False)
        
    elif data == 'auto':
        await query.message.reply_text("ğŸ¤– Modo automÃ¡tico...")
        await auto_resolver(query, context)
        
    elif data == 'screenshot':
        await screenshot_command(query, context)
        
    elif data.startswith('switch_'):
        client_name = data.replace('switch_', '')
        context.user_data['current_client'] = client_name
        await query.edit_message_text(f"âœ… Trocado para: **{client_name}**", parse_mode='Markdown')
        
    elif data.startswith('select_'):
        letter = data.replace('select_', '')
        if current_client and current_client in sessions:
            session = sessions[current_client]
            success, message = session.select_answer(letter)
            await query.answer(message)
            await query.edit_message_text(f"{query.message.text}\n\n{message}", parse_mode='Markdown')
    
    elif data == 'submit':
        if current_client and current_client in sessions:
            session = sessions[current_client]
            success, message = session.submit_answer()
            await query.answer(message)
            await query.edit_message_text(f"{query.message.text}\n\n{message}", parse_mode='Markdown')
    
    elif data == 'next':
        if current_client and current_client in sessions:
            session = sessions[current_client]
            success, message = session.next_question()
            await query.answer(message)
    
    elif data == 'retry_claude':
        await query.message.reply_text("ğŸ”„ Tentando com Claude...")
        await resolver_questao(query, context, use_claude=True)


async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra status atual"""
    user_id = update.effective_user.id
    
    if user_id != YOUR_TELEGRAM_ID:
        return
    
    current = context.user_data.get('current_client', 'Nenhum')
    
    text = f"ğŸ“Š **Status**\n\n"
    text += f"â–¶ï¸ Cliente atual: **{current}**\n"
    text += f"ğŸ‘¥ Total clientes: {len(sessions)}\n\n"
    
    if current != 'Nenhum' and current in sessions:
        session = sessions[current]
        text += f"ğŸ¯ QuestÃµes resolvidas: {session.questions_solved}\n"
        text += f"ğŸŒ URL: {session.driver.current_url if session.driver else 'N/A'}\n"
        text += f"â° SessÃ£o iniciada: {session.created_at.strftime('%H:%M:%S')}"
    
    await update.message.reply_text(text, parse_mode='Markdown')


async def sair_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Encerra sessÃ£o do cliente atual"""
    user_id = update.effective_user.id
